---
layout: post
title: iOS - 内存管理
date: 2018-04-20 10:41:00.000000000 +09:00
---


1、内存中五大区域

栈区（stack）：储存局部变量、函数的参数值，当期作用域执行完毕之后，就会被系统立即收回，由编译器自动分配释放，其操作方式类似于数据结构中的栈，栈内存分配运算内置于指令集，效率很高，但是分配的内存容量有限，比如iOS中栈区的大小是2M。

堆区（heap）：（就是通过new、malloc、realloc 分配的内存块，他们的释放编译器不去管，有我们的引用程序去释放，如果应用程序没有释放掉，操作系统会自动回收，分配方式类似于链表）存放OC对象，手动申请的空间，手动释放（ARC自动释放）。

静态区：初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后，由系统释放。

常量区：常量存储在这里，不允许被修改。

代码段：代码，函数体的二进制代码，直到程序结束才会被立即收回。

（对于栈来说，内存管理由编译器释放，对于堆来说，释放工作由程序员释放；栈的空间大小比堆小很多；栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，所以分配效率比堆高；栈中存储的变量出了作用域就无效了，比如下面的函数，出了}变量i 和 j 的作用域已经结束了，编译器就会自动放掉i 和 j 所占的内存（理解好作用域就理解了栈区的内存分配），而堆由于是程序员进行控制释放的，变量的生命周期可以延长）

{% highlight ruby %}

- (void)print {
int i = 10;
int j = 20;
NSLog(@"i+j = %d", (i+j));
}

{% endhighlight %}

2、除了堆区存储的数据，都是系统自动释放的。堆区中的OC对象，是不会主动释放的，如果不释放，在程序结束时候才释放。

3、引用计数：每个oc对象都有一个属性，叫做引用计数，retainCount。当新的引用指向对象，那么这个对象的引用计数+1，少一次引用，引用计数-1，当引用计数为0的时候，代表这个对象被释放了，系统自动回收掉此对象，回收这个对象的同时，自动调用这个对象的dealloc方法。

retain  + 1

release -1



4、MRC 和ARC的区别就是是否手动管理引用计数。ARC 是基于MRC的。

5、内存管理原则，谁创建，谁释放。

6、野指针。在C中，声明一个指针变量，没有为这个指针变量初始化，那么这个指针变量的值就是一个垃圾值，指向随机的一块空间，那么我们叫做野指针。在OC中，一个指针指向的对象被释放了，那么这个指针叫做野指针。怎么判断，遇着预防野指针，不好判断。只能靠良好的编程习惯，避免。

7、MRC下管理需要注意：避免提前释放；避免过度释放；多个模块操作同一个对象，不知道最后由谁释放；多线程操作，不确定哪个线程最后使用完毕。ARC 下可能带来的内存泄漏的：循环引用

9、assign 和weak 有什么区别

weak 之修饰对象，assign 修饰对象、基本数据类型。当需要修饰对象类型时，MRC时代使用unsafe_unretained。当然，unsafe_unretained也可能产生野指针，所以它名字是"unsafe_”。

assign 修饰的对象，引用计数+1，weak不变。对象销毁后，weak修饰的属性自动设置为nil，最大的好处就是之后发送的消息都不会因为对象销毁而出错，assign 修饰的属性，并不会自动变为nil，形成野指针，所以再调用这个对象，发送消息会导致crash。assign 修饰基本数据类型是安全的，不会造成这个问题，因为assign 修饰基本数据类型，没有引用计数了，值类型会被放入栈中，遵循先进后出的原则，由系统负责栈内存。而引用放在堆中，需要我们手动管理内存，或者ARC管理。

weak 修饰delegate 和block 等引用类型，不会造成野指针问题，也不会循环引用，非常安全。







