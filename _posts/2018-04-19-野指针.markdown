---
layout: post
title: 指针、野指针、空指针、地址
date: 2018-04-19 16:00:00.000000000 +09:00
---

1、什么是指针？

指针本身具有独立的数据类型，可以用这个类型声明 一个指针变量并赋值，这个指针变量是用来保存某个内存的地址。指针变量本身也是占有内存的，这个内存使用来存写地址数据的。（指针变量是用来存储地址的，地址是一串数字。）

指针是用来保存地址的，但是指针有类型，比如说int 型指针，char型指针，float 型指针，double 型指针等，指针变量和其他变量是一样的。指针的类型 表明，你希望从存储的地址里面取出来的数据，或者存进去的数据，是什么类型的。

指针一定只能保存地址，保存地址使用的是指针变量。 `指针变量必须初始化`，否则不知道指向哪个地址，成为野指针。任何指针被创建时不会自动成为null指针（空指针），它会乱指一气。所以要么设置为NULL，要么指向合法内存。指针被release后，并不是一个合法的指针，只是把指针所指的内存给释放掉了，并没有把指针本身干掉，用if (p != NULL) 进行防错处理，不能起到防错作用，因为这时候指针不是空指针，也不知想合法的内存块，是一个野指针。可以通过这个地址来操作对应的内容。只要知道了一个变量的内存地址，就可以通过指针来操作这块内存空间。指针在C语言中占8个字节。

系统类型可以在编译时进行类型检测，让编译器帮助避免犯错，不然还得等到程序运行的时候才能发现。类型可以指明指针这块内存地址所保存的二进制数据。


{% highlight ruby %}
//1、定义一个int 型常量a，p 就是用来存储a的地址的，&a就是取a的地址。int * 表示指针变量p 是int型指针，里面存储的地址所指向的数据是int型

int a = 0;

int* p = &a;// int* p 等价于 int *p  * 在表示指向的时候，*只是说明这个变量是指针，对于操作的时候，*表示操作地址。

printf("a = %d\n",(int) sizeof(p));// p变量占8个字节，说明指针在C语言中占 8个字节



//2、 指针变量只能保存地址

int *x = 10;//错误，指针变量只能保存地址  &a

int *y = a;//错误，指针变量只能保存地址  &a



//3、 z = &b 以下打印的全是b的地址
int b = 10;

int *z = &b;

printf("%p\n",&b);

printf("%p\n",z);


//4、声明指针变量时候的* 和操作地址的时候的 * 的区别 .一个是定义，一个是寻找并操作. *p 指的是 找到这块地址里面对应的数据，并进行操作，这里 *p 是寻找并操作。
int  u = 10;

int *w = &u;

*w = 20;

printf("指针w 的占多少字节 ---- %d\n",(int) sizeof(w));

printf("u ---- %d\n",u);

printf("&u的地址 ---- %p\n",&u);

printf("w ---- %p\n",w);

printf("*w ---- %p\n",*w);

*w = &u;//这个是错误的，*w代表寻找w 存放的地址对应的数据，并操作，不能给他赋值 地址。

//5、利用指针来接收变量的地址

int m = 10;

change(&m);

printf("m ---- %d\n",m);

//6、取地址符 &取地址，指针保存地址

int d = 10;

int *c = &d;//c 保存d的地址

printf("*c ---- %d\n",*c);//找到 *c 对应的地址 里面所保存的数据

//修改指针指向的那块内存空间
*c = 1000;

printf("*c ---- %d\n",*c);//找到 *c 对应的地址 里面所保存的数据


{% endhighlight %}



2、什么是空指针？

没有存储地址的指针就称为空指针（NULL指针）。空指针就是被赋值为0的指针，在没有被初始化之前，其值为0。


3、什么是野指针？

野指针不是NULL 指针，是指向“垃圾”内存（不可用内存）的指针，野指针非常危险。

指针所指向的内存已经被回收，对象已经被释放，但是对该指针没有做任何修改，以至于该指针仍然指向已经回收的内存地址，此情况下该指针便称为野指针。野指针，`随机性强`，`难以定位`。

随机性强：有人说，野指针是crash界的半壁江山。内存被释放不代表内存会立刻被覆写或者数据受到破坏，这时候访问这块内存不一定会出错。多线程带来了复杂的应用运行环境，在这个环境下，没加保护的数据可能是致命的。设计不严谨的代码也是造成野指针异常的原因。

难以定位：野指针是C语言层面，往往只能获取到系统栈信息，单单是定位错误代码已经很难了，重现修复更难。

怎么解决野指针： 定位野指针，`Scheme --> Edit Scheme --> Diagnostics --> objective --> c的Enable zombie objects`。使用僵尸对象，所谓僵尸对象，就是将释放的对方标记为僵尸，系统不会回收这些对象的内存，并让这些内存无法被重用，因而无法被覆写。在启用“僵尸对象”后，在调试期间，如果对象被释放了，会被转化为“僵尸对象”。如果再向对象发送消息，则对应的“僵尸对象”会受到这个消息，并抛出异常。异常信息中会明确描述被释放的对象，以及接受的是哪个消息。

使用野指针访问僵尸对象，有时候会出问题，有时候不会出问题。当野指针指向的将是对象所占用的空间还没有分配给别人的时候，这个时候其实是可以访问的，因为对象的数据还在。当野指针指向的对象所占用的空间分配给别人的时候，这个时候再访问就会出问题。不允许野指针去访问僵尸对象。

可以开启僵尸对象的检测，但是不要默认开启，因为一旦开启，每次通过指针访问对象的时候，都回去检查指针指向的对象是否为僵尸对象，影响效率。

4、避免僵尸对象报错，当一个指针变为野指针以后，把这个指针的值设置为nil。nil 可以发送任何消息，不会崩溃。

5、关于内存回收的本质

申请一块空间，实际上是向系统申请1块别人不再使用的空间。

释放一块空间，指的是占用的空间不再使用，这个时候系统可以分配给别人去使用。在这个空间费赔给别人之前，数据还是存在的。oc对象释放以后，表示oc对象占用的空间可以分配给别人，但是在分配给别人之前，这个空间仍然存在，对象的数据仍然存在。

6、产生野指针的原因 (暂时知道的先添加，后续理解多了再添加)

访问已释放的对象。

__unsafe_unretained 



[SusisePointerProject]


[SusisePointerProject]: https://github.com/Susise/SusisePointer

