<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>iOS - 面试题</title>
  <meta name="description" content="面试题 一">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="iOS - 面试题">
  <meta name="twitter:description" content="面试题 一">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="iOS - 面试题">
  <meta property="og:description" content="面试题 一">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2018/04/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <link rel="alternate" type="application/rss+xml" title="Susise" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Susise 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Susise logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Susise" class="blog-button">Susise</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">To be the one that you want to be</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">Love.Action.Hope.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">Blog</a></li>
                
                  <li class="navigation__item"><a href="https://github.com/Susise" target="_blank" title="My Projects">Projects</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/p/1005055503228222" title="@p/1005055503228222 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/Susise" title="@Susise 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:s_qiaoqiao@163.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-red"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-04-20 11:34:00 +0900" itemprop="datePublished" class="post-meta__date date">2018-04-20</time> &#8226; <span class="post-meta__tags tags"></span>
    </div>
    <h1 class="post-title">iOS - 面试题</h1>
  </header>

  <section class="post">
    <p>面试题 一</p>

<p>基础</p>

<p>1、为什么说Objective-C是 动态的语言 ?</p>

<p>动态加载：比如2x、3x图片，根据机型动态加载图片</p>

<p>动态类型：运行时再决定对象的类型，简单说就是id类型。任何对象都可以被id指针所指，只有在运行时，才能决定是什么类型。像内置的明确的基本类型都属于静态类型 （int NSString等），静态类型在编译的时候就能被识别出来，所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(runtime)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。</p>

<p>动态绑定： 基于动态类型，在某个实例对象被确定后，其类型便被确定了。该对象对应的属性和响应的消息也被完全确定，这就是动态绑定。比如我们一般向一个<code class="highlighter-rouge">NSObject</code> 对象发送  <code class="highlighter-rouge">-respondsToSelector:</code> 或者 <code class="highlighter-rouge">-instancesRespondToSelector:</code> 等来确定对象是否可以对某个<code class="highlighter-rouge">SEL</code>做出响应，而在OC消息转发机制被触发之前，对应的类 的<code class="highlighter-rouge">+resolveClassMethod:</code>和<code class="highlighter-rouge">+resolveInstanceMethod:</code>将会被调用，在此时有机会动态地向类或者实例添加新的方 法，也即类的实现是可以动态绑定的；<code class="highlighter-rouge">isKindOfClass</code>也是一样的道理。</p>

<p>2、讲一下MVC和MVVM，MVP?</p>

<p>Model 、View、Controller。Model是业务数据层，View是用户界面，Controller控制器处理逻辑、网络请求。C作为Model和View之间的连接。</p>

<p>Model、View、ViewModel、Model。相对于MVC ，把C的逻辑处理、网络请求挪一部门到viewmodel中，减轻c的压力。</p>

<p>MVP  没用过，不是很了解，等理解了再添加。</p>

<p>3、为什么代理要用 <code class="highlighter-rouge">weak</code> 修饰? <code class="highlighter-rouge">tablveview</code> 的 <code class="highlighter-rouge">delegate</code> 和 <code class="highlighter-rouge">dataSource</code>有什么区别? <code class="highlighter-rouge">block</code> 和代理的区别?  <code class="highlighter-rouge">block</code>  的内存是怎么管理的，<code class="highlighter-rouge">block</code>   分哪几种 <code class="highlighter-rouge">block</code>  ？
 
因为代理不归声明代理的的类所拥有，归遵循代理的类所拥有，如果用strong的话，两者都拥有，那么在释放遵循代理的时候类的对象的时候，内存不能完全释放，会造成内存泄漏。</p>

<p><code class="highlighter-rouge">delegate</code>  是操作方面的代理方法。<code class="highlighter-rouge">dataSource</code>  是数据方面的代理方法。</p>

<p><code class="highlighter-rouge">block</code>  和 <code class="highlighter-rouge">delegate</code> 都可以实现回调。 <code class="highlighter-rouge">block</code>  更轻型，使用简单方便，能够直接访问上下文，这样类中不需要储存临时数据，使用 <code class="highlighter-rouge">block</code> 的代码通常会在同一个地方，代码连贯。<code class="highlighter-rouge">delegate</code> 相对来说，重一些，需要实现接口，方法分离开，有时候需要储存临时数据，个人感觉没有 <code class="highlighter-rouge">block</code> 连贯。所以建议优先使用<code class="highlighter-rouge">block</code> 。</p>

<p>多个相关方法，适用于  <code class="highlighter-rouge">delegate</code> 。 假如每个方法都设置一个<code class="highlighter-rouge">block</code>，这个比较麻烦，让  <code class="highlighter-rouge">delegate</code> 多分方法分成一组，只需要设置一次，就可以多次回调。当多余3个方法优先使用 <code class="highlighter-rouge">delegate</code> 。</p>

<p>为避免循环引用，适用于  <code class="highlighter-rouge">delegate</code> 。使用 <code class="highlighter-rouge">block</code> 稍微不注意就形成循环引用，倒追对象释放不了，这种循环引用，比较难检查，<code class="highlighter-rouge">delegate</code>  是分离开的，不引用上下文，相对安全些。</p>

<p>封装库供别人使用的时候，适用于  <code class="highlighter-rouge">delegate</code>。</p>

<p><code class="highlighter-rouge">block</code>  分三种，存在堆上的  <code class="highlighter-rouge">block</code>  ，存在栈上的  <code class="highlighter-rouge">block</code> ，全局的  <code class="highlighter-rouge">block</code> 。全局  <code class="highlighter-rouge">block</code>  相当于单利。栈上的  <code class="highlighter-rouge">block</code>  超出作用域 马上被销毁，堆上的  <code class="highlighter-rouge">block</code>  是一个带有引用计数的对象，需要自行管理其内存。</p>

<p><code class="highlighter-rouge">block</code> 之前使用MRC的人习惯用 copy 修饰。因为方法内容的 <code class="highlighter-rouge">block</code>  是在栈区，使用copy 把它放到堆区，延长其生命周期，因为block 如果在栈上的话，其所属的变量作用域结束，该block 就被释放掉了，block 中的 __block 变量也同事被释放掉，为了解决栈块在其变量作用于结束之后被释放掉的问题，所以需要把block 复制到堆中。ARC 中，编译器自动对block进行copy操作，写不写copy都行。</p>

<p>栈上的block copy 是从 栈复制到 堆上，堆上的block copy 引用计数 +1，全局的block copy，什么也不做。</p>

<p>__block 到底做了什么，为什么加上__blcok 就可以修改 block 外面的变量了。</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"> 
 <span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">testMthod</span><span class="p">{</span>
 
 <span class="sr">/*
 block 会把 i变量复制为自己私有的const 变量，也就是说 block 会 捕获栈上 变量（或指针），将其复制为自己的私有变量，在进行i= 50 的操作的时候，block 已经将其复制为自己的私有变量，所以这里修改 堆block里面的 i 不会造成任何影响
 */</span>
 
 <span class="no">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
 
 <span class="n">void</span><span class="p">(</span><span class="o">^</span><span class="n">testBlock</span><span class="p">)(</span><span class="n">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
 <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"%ld"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
 
 <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"no -- __block --- %p"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
 <span class="p">};</span>
 
 <span class="n">i</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
 
 <span class="n">testBlock</span><span class="p">();</span>
 
 <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"no -- __block ---%p"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
 
 <span class="p">}</span>
 <span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">testMthod1</span><span class="p">{</span>
 
 <span class="sr">/*
 i 是一个局部变量，存储在栈区的。给i 加上 __block 修饰符所起的作用就是只要观察到 该变量 被block 所持有，就将该变量在栈中的内存地址放到堆中，此时不管block 外部还是内部，i 的内存地址都是一样的，进而不管block 外部还是内部，都可以修改i 变量的值，所以i
 = 50 以后，在block 里面输出的值就是50了
 */</span>
 
 <span class="n">__block</span> <span class="no">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
 
 <span class="n">void</span><span class="p">(</span><span class="o">^</span><span class="n">testBlock</span><span class="p">)(</span><span class="n">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
 <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"__block = %ld"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
 
 <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">" __block ---%p"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
 <span class="p">};</span>
 
 <span class="n">i</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
 
 <span class="n">testBlock</span><span class="p">();</span>
 
 <span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">" __block ---%p"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
 
 
 </code></pre></figure>

<p>block 循环引用的问题？ 使用系统的block api 是否也考虑循环引用的问题，weak 和strong 之间的区别？</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  
 <span class="sr">/*
 self 对block 有一个强引用，而在block 内部又对self进行一次强引用，这样就形成了一个封闭的环，当self 释放，self对block的强引用被取消，但是 block 对self 没有取消，所以会造成 self没有释放，造成内存泄漏
 */</span>
 <span class="nb">self</span><span class="p">.</span><span class="nf">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
 <span class="p">[</span><span class="nb">self</span> <span class="n">dosomething</span><span class="p">];</span>
 <span class="p">};</span>
 
 <span class="sr">/*
 weakself之后，block 对self的强引用关系就变成了弱引用关系，这样属性所指的对象遭到摧毁的时候，属性值也会被清空，打破了block 捕获的作用域带来的循环引用。
 */</span>
 
 <span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakself</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
 <span class="nb">self</span><span class="p">.</span><span class="nf">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
 <span class="p">[</span><span class="n">weakself</span> <span class="n">dosomething</span><span class="p">];</span>
 <span class="p">};</span>
 
 <span class="sr">/*
 在这种情况下是不需要考虑循环引用的，因为这里只有block对self进行了一次强引用，属于单向的强引用，没有形成循环引用。
 
 */</span>
 <span class="p">[</span><span class="no">UIView</span> <span class="n">animateWithDuration</span><span class="p">:</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="n">animations</span><span class="ss">:^</span><span class="p">{</span>
 <span class="p">[</span><span class="nb">self</span> <span class="n">dosomething</span><span class="p">];</span>
 <span class="p">}];</span>
 
  </code></pre></figure>

<p><a href="https://github.com/Susise/SusiseBlock">Demo</a></p>

<p>4、属性的实质是什么?包括哪几个部分?属性默认的关键字都有哪些?@dynamic关键 字和@synthesize关键字是用来做什么的?</p>

<p>属性的实质是描述特征 @property 是在声明一个属性，本质由三部分组成，带下划线的成员变量（ivar） + setter + getter  </p>

<p>@synthesize 只有一个目的——给实例变量起个别名</p>

<p>如果同时重写setter 和getter 方法的话，必须 @ synthesize age = _age; 不然会报错_age. 不存在。</p>

<p>实现 property 所声明的方法的定义，其实说直白就像是 property声明了一些成员变量的访问方法，synthesize  则定义了由 property 声明的方法的实现。</p>

<p>他们之前的对应关系是 property 声明方法-&gt;头文件中声明getter 和setter方法，synthesize定义方法在.m中的 getter 和 setter 方法的实现</p>

<p>在 xcode 4.5以及以后的版本中，可以省略 @synthesize 编译器会自动帮你加上 getter 和 setter 方法的实现，并且默认回去访问_age这个成员变量，如果找不到 _age这个成员变量，会自动生成一个叫做_age的私有成员变量，在 .m中同时实现getter和setter时候，需要 @ synthesize age = _age</p>

<p>@dynamic 自定义setter 和getter方法</p>

<p>告诉编译器:属性的 setter,getter 方法有用户自己实现,不自动生成.假如一个属性被声明为@dynamic var 那么如果不实现setter getter方法,编译阶段不会报错,但是一旦使用 instance.var = someVar ,crash</p>

<p>5、属性的默认关键字是什么?</p>

<p>基本数据类型：readwrite、assign、atomic 、OC对象 readwrite、strong、atomic </p>

<p>6、NSString 为什么要 copy关键字，如果 strong 会有什么问题?(注意:这没有说 strong 就一定不行 。使 copy 和 strong 是看情况而定的)</p>

<p>本身是无所谓的，就是当 NSString 指向一个NSMutableString 的时候就不可以了。Copy是为了安全， 防止 NSMutuableString 赋值给NSString的时候，NSMutableString 修改引起 NSString 值变化而用的, 如果用strong，把 NSMutuableString 的值给 NSString 的变量的时候，拷贝的是地址，NSMutuableString变，那么 NSString 的变量也在跟着变，copy的话出来一块新的内存，并且把内容放到新内存里面。</p>

<p>浅复制：不拷贝对象本身，仅仅是拷贝指向对象的指针，所以不管改变原对象还是拷贝后的对象，两个对象都会改变。 strong</p>

<p>深复制：是直接拷贝整个对象内存到另一块内存中 copy</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">NSMutableString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="no">NSMutableString</span> <span class="n">stringWithFormat</span><span class="p">:</span><span class="err">@</span><span class="s2">"hello world"</span><span class="p">];</span>
<span class="nb">self</span><span class="p">.</span><span class="nf">str1</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
<span class="nb">self</span><span class="p">.</span><span class="nf">str2</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>

<span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"str:%p"</span><span class="p">,</span><span class="n">str</span><span class="p">);</span><span class="sr">//s</span><span class="n">tr</span><span class="p">:</span><span class="mh">0x60400045c230</span>

<span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"copy_str %p "</span><span class="p">,</span><span class="nb">self</span><span class="p">.</span><span class="nf">str1</span><span class="p">);</span><span class="sr">//</span><span class="n">copy_str</span> <span class="mh">0x604000433a40</span>

<span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"strong_str %p "</span><span class="p">,</span><span class="nb">self</span><span class="p">.</span><span class="nf">str2</span><span class="p">);</span><span class="sr">//s</span><span class="n">trong_str</span> <span class="mh">0x60400045c230</span>

<span class="sr">//</span> <span class="n">str</span> <span class="err">和</span><span class="n">str2</span> <span class="err">地址相同，和</span><span class="n">str1</span> <span class="err">地址不同，</span>

<span class="p">[</span><span class="n">str</span> <span class="n">appendString</span><span class="p">:</span><span class="err">@</span><span class="s2">" Susise"</span><span class="p">];</span>

<span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"appendString --- %@"</span><span class="p">,</span><span class="n">str</span><span class="p">);</span><span class="sr">//</span><span class="n">appendString</span> <span class="o">---</span> <span class="n">hello</span> <span class="n">world</span> <span class="no">Susise</span>

<span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"appendString --- %@"</span><span class="p">,</span><span class="nb">self</span><span class="p">.</span><span class="nf">str1</span><span class="p">);</span><span class="sr">//</span><span class="n">appendString</span> <span class="o">---</span> <span class="n">hello</span> <span class="n">world</span>

<span class="no">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">"appendString --- %@"</span><span class="p">,</span><span class="nb">self</span><span class="p">.</span><span class="nf">str2</span><span class="p">);</span><span class="sr">//</span><span class="n">appendString</span> <span class="o">---</span> <span class="n">hello</span> <span class="n">world</span> <span class="no">Susise</span>

<span class="sr">//</span><span class="err">经过</span><span class="n">copy</span><span class="err">关键字修饰的</span><span class="n">str1</span><span class="err">并没有因为</span><span class="n">str</span><span class="err">的变化而变化，经过</span><span class="n">strong</span> <span class="err">修饰过的</span><span class="n">str2</span> <span class="err">却随着</span> <span class="n">str</span><span class="err">的改变而改变。一般强胯下，我们不希望字符串的值随着原值改变，所以我们一般用</span><span class="n">copy</span> <span class="err">修饰</span><span class="n">string</span><span class="err">属性。如果希望字符串的值跟着赋值的字符串的值变化，可以使用</span><span class="n">strong</span><span class="err">。</span>

<span class="sr">//</span><span class="err">上面的轻局昂是针对</span><span class="no">NSMutableString</span><span class="err">赋值给</span><span class="no">NSString</span><span class="err">的时候</span> <span class="err">，才会有不用，如果是赋值是</span><span class="no">NSString</span><span class="err">对象，那么使用</span><span class="n">copy</span><span class="err">还是</span><span class="n">strong</span><span class="err">，结果都是一样的。因为</span><span class="no">NSString</span><span class="err">对象根本就不能改变自身的值，他是不可变的。</span>

<span class="sr">//s</span><span class="n">trong</span><span class="err">，</span><span class="n">copy</span><span class="err">对引用计数的印象是一样的，都是会怎家内存引用计数的，都需要在最后做处理。</span>

<span class="sr">//s</span><span class="n">trong</span> <span class="err">浅拷贝</span> <span class="n">copy</span> <span class="err">深拷贝</span>

  </code></pre></figure>

<p><a href="https://github.com/Susise/SusiseStringCopy">StringDemo</a></p>

<p>7、如何令所写的对象具有拷贝功能? 如何重写带copy关键字的 setter？</p>

<p>实现NSCopying协议，为什么要拷贝，拷贝不一定生成新的对象，大部分生成，只有 [nsstring copy]的时候不生成新对象，地址一样，内容一样，节省空间，不生成新的。拷贝的特点，新的不影响旧的，旧的不影响新的 </p>

<p>要想实现拷贝功能，需要实现拷贝协议 <code class="highlighter-rouge">NSCopying 协议</code>，自定义对象分为可变对象和不可变对象，需要同时实现NSCopying与 NSMutableCopying协议。</p>

<p><a href="https://github.com/Susise/SusiseStringCopy">StringDemo</a></p>

<p>8、可变集合类 和不可变集合类的 copy 和 mutablecopy有什么区别?如果是集合是内容复制的话，集合的元素也是内容复制么?</p>

<ul>
  <li>
    <p>对不可变的非集合对象，copy是指针拷贝，mutablecopy是内容拷贝</p>
  </li>
  <li>
    <p>对于可变的非集合对象，copy，mutablecopy都是内容拷贝</p>
  </li>
  <li>
    <p>对不可变的数组、字典、集合等集合类对象，copy是指针拷贝，mutablecopy是内容拷贝</p>
  </li>
  <li>
    <p>对于可变的数组、字典、集合等集合类对象，copy，mutablecopy都是内容拷贝</p>
  </li>
</ul>

<p>但是，对于集合对象的内容复制仅仅是对对象本身，但是对象的里面的元素还是指针复制。要想复制整个集合对象，就要用集合深复制的方法，有两种：</p>

<p>（1）使用initWithArray:copyItems:方法，将第二个参数设置为YES即可</p>

<p>NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES];</p>

<p>（2）将集合对象进行归档（archive）然后解归档（unarchive）：</p>

<p>NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
 
9、为什么IBOutlet修饰的UIView也适 weak关键字?</p>

<p>因为 XIB 或者 SB 已经对UIView 拥有了，controller 就用 weak，不然再退出本页面的时候，无法销毁，造成内存泄漏</p>

<p>10、nonatomic 和 atomic 的区别 ? atomic 是绝对的线程安全么 ? 为什么?如果不是，那应该如何实现?</p>

<p>Atomic 和 nonatomic的区别在于，系统自动生成的setter/getter方法不一样，如果自己写getter/setter 那么atomic/nonatomic 这些关键字只是提示作用，写不写都一样。Atomic属性生成的getter/setter会保证get、set操作的完整性，不受其他线程影响，nonatomic没有这个保证，所以nonatomic的速度比atomic块，不过atomic不能保证线程安全，如果线程A调了getter，与此同时，线程B、线程C都调用了setter，那最后线程A get到的值，有3中可能，使用atomic不是一定的线程安全。保证数据完整性，这个多线程变成的最大挑战，往往需要借助其他手段。</p>

<p>nonatomic的内存管理语义是非原子性的，非原子性的操作本来就是线程不安全的，而atomic的操作是原子性的，但是并不意味着它是线程安全的，它会增加正确的几率，能够更好的避免线程的错误，但是它仍然是线程不安全的。当使用nonatomic的时候，属性的setter，getter操作是非原子性的，所以当多个线程同时对某一属性读和写操作时，属性的最终结果是不能预测的。可以通过线程锁来增加安全性。据说，atomic要比nonatomic慢大约20倍。一般如果条件允许，我们可以让服务器来进行加锁操作。</p>

<p>线程锁，这里有一篇关于线程锁的不错的文章 <a href="https://www.jianshu.com/p/35dd92bcfe8c">线程锁</a></p>

<p> 11、UICollectionView 定义layout如何实现?</p>

<ul>
  <li>
    <p>(void)prepareLayout 系统在准备对item进行布局前会调用这个方法</p>
  </li>
  <li>
    <p>(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect</p>
  </li>
  <li>
    <p>(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath</p>
  </li>
  <li>
    <p>(NSMutableArray *)layoutAttributes 存储所有cell属性的arr </p>
  </li>
</ul>

<p>12、StoryBoard开发界面有什么弊端?如何避免?</p>

<p>优点：减少代码量、快、直观可见</p>

<p>缺点：version control容易冲突，队友的的xcode版本和你的xcode版本不一样的时候，多人协作困难。如果换一拨人的话，可能不叫难继续开发。感觉复用性差</p>

<p>个人比较习惯用代码。 </p>

<p>13、进程和线程的区别?同步异步的区别?并行和并发的区别? 
 进程：类似于打开QQ、迅雷、这是一个一个的进程</p>

<p>线程：迅雷里面的一个下载任务，是一个线程；</p>

<p>同步：按照顺序往下执行、烧完水再泡茶</p>

<p>异步：烧水的时候同时可以洗茶具，可同时进行</p>

<p>并行：一次能执行多个任务</p>

<p>串行，一次只能执行一个任务</p>

<p>14、线程间通信?</p>

<p><a href="https://github.com/Susise/GCD">线程间的通信</a></p>

<p>15、GCD的一些常用的函数 ? (group，barrier，信号 ，线程同步)</p>

<p><a href="https://github.com/Susise/GCD">线程间的通信</a></p>

<p>16、如何使 队列来避免资源抢夺?</p>

<p><a href="https://www.jianshu.com/p/35dd92bcfe8c">线程锁</a></p>

<p>17、数据持久化的几种方案(fmdb用没用过)  </p>

<p>plist文件 （属性列表）</p>

<p>preferencece （偏好设置）</p>

<p>NSKeyedArchiver（归档）</p>

<p>SQLite3</p>

<p>CoreData</p>

<p>FMDB</p>

<p><a href="https://www.jianshu.com/p/7616cbd72845">数据持久化</a></p>

<p>18、说 下AppDelegate的 个 法?从后台到前台调 哪些方法?第 次启动调 哪些 法?从前台到后台调用哪些方法?</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">–</span> <span class="p">(</span><span class="no">BOOL</span><span class="p">)</span><span class="n">application</span><span class="p">:(</span><span class="no">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="n">application</span> <span class="n">didFinishLaunchingWithOptions</span><span class="p">:(</span><span class="no">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">launchOptions</span>  <span class="err">程序启动，不包括前台转后台</span>

<span class="o">*</span>      <span class="o">-</span><span class="err"> </span><span class="p">(</span><span class="no">BOOL</span><span class="p">)</span><span class="n">application</span><span class="p">:(</span><span class="no">UIApplication</span><span class="err"> </span><span class="o">*</span><span class="p">)</span><span class="n">application</span><span class="err"> </span><span class="n">didFinishLaunchingWithOptions</span><span class="p">:(</span><span class="no">NSDictionary</span><span class="err"> </span><span class="o">*</span><span class="p">)</span><span class="n">launchOptions</span><span class="err">  </span>
<span class="o">*</span>       <span class="p">{</span><span class="err">  </span>
<span class="o">*</span>          <span class="err">    </span><span class="o">/</span><span class="sr">/ Override point for customization after application launch.  
*             NSLog(@"\n ===&gt; 程序开始 !");   
*               
*             return YES;  
*         }  
*                                       
*         - (void)applicationWillResignActive:(UIApplication *)application  
*         {  
*               
*             NSLog(@"\n ===&gt; 程序暂行 !");   
*         }  
*           
*         - (void)applicationDidEnterBackground:(UIApplication *)application  
*         {  
*               
*              NSLog(@"\n ===&gt; 程序进入后台 !");   
*         }  
*           
*         - (void)applicationWillEnterForeground:(UIApplication *)application  
*         {  
*               
*              NSLog(@"\n ===&gt; 程序进入前台 !");   
*         }  
*           
*         - (void)applicationDidBecomeActive:(UIApplication *)application  
*         {  
*             NSLog(@"\n ===&gt; 程序重新激活 !");   
*               
*         }  
*           
*         - (void)applicationWillTerminate:(UIApplication *)application  
*         {  
*             NSLog(@"\n ===&gt; 程序意外暂行 !");   
*           
*             UIDevice *device = [UIDevice currentDevice];  
*               
} 

首次运行：
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
- (void)applicationDidBecomeActive:(UIApplication *)application
 
 首次关闭（home）：
 - (void)applicationWillResignActive:(UIApplication *)application
 - (void)applicationDidEnterBackground:(UIApplication *)application
 
 再次运行：
 - (void)applicationWillEnterForeground:(UIApplication *)application
 - (void)applicationDidBecomeActive:(UIApplication *)application
 
 再次关闭：
 - (void)applicationWillResignActive:(UIApplication *)application
 - (void)applicationDidEnterBackground:(UIApplication *)application
  
 </span></code></pre></figure>

<p> </p>

<p> 19、NSCache优于NSDictionary的几点? 
 
 NSCache是苹果官方提供的的缓存类，具体使用是和NSDictionary很相似的，在AFNetworking和SDWebImage第三方框架中被用作管理缓存。
 NSCache在系统内存很低时会自动释放对象，但是在模拟器进行演示的时候不会释放，这一点要注意，所以最好是在内存进行警告时主动去调用方法去释放对象
 
 NSCache是线程安全的，在进行多线程操作时，不需要进行加锁。
 
 NSCache的Key只是对对象进行了Strong引用，而非拷贝，相关说明会在下面的例子中进行详细解释。
 
 NSCache的KEY是不需要遵循NSCopying协议的，也就是说，作为KEY的对象并不会被拷贝，利用这点，可以做出一些NSDictionary无法实现的效果
 
 20、知道DesignatedInitializer?使用它的时候有什么需要注意的问题? 
 
 DesignatedInitializer 指定初始化函数，就是说初始化必须使用该函数。
 
 子类如果有指定初始化函数，那么指定初始化函数实现时必须调用他的直接父类的指定初始化函数。
 
 如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其他初始化函数，不能调用super的初始化函数。
 
 如果子类提供了指定初始化函数，那么一定要实现所有父类的指定初始化函数。
  
 21、实现description 法能取到什么效果?  
 
 description 默认返回类名和地址，意义不大，可以重写description来打印所有的属性值
 
 22、objc使什么机制管理对象内存?  
 
 引用计数，引用计数大于0 ，表示该对象可用，引用计数等于0，表示该对象不可用，已被释放。
 
 中级
 
 Block 
 
 23、 block的实质是什么?  共有几种种block? 都是什么情况下产生的?
 
 部门答案在问题3里面。 Blcok实质是函数块。是对C的闭包实现，是一个带有局部变量的匿名函数。</p>

<p>Clang （LLVM） 通过clang 命令行工具中的 -rewrite-objc 参数，我们可以把OC代码转化为C++的实现，帮助文档中的书名是这样的：Rewrite Objective-C source to C++。</p>

<p>  24、为什么在默认情况下无法修改被block捕获的变量? __block都做什么? 模拟下循环引的个情况 ? block实现界面反向传值如何实现? 
 
 答案在问题3里有解释。</p>

<p> 
 25、objc在向一个对象发送消息时，发生了什么?  
 
 26、什么时候会报unrecognizedselector错误?iOS有哪些机制来避免 到这 步?  
 
 27、能否向编译后得到的类中增加实例变量?能否向运行时创建的类中添加实例变量 ? 为什么?  
 
 28、runtime如何实现weak变量的置nil?  
 
 Runtime 对注册的类 会进行布局，对于weak 对象 会放入一个hash 表中，用weak 指向的对象内存地址作为key，档次对象的引用计数为0的时候就会dealloc。加入weak指向的对象 内存地址是a，那么就会以a为键，在这个weak 表中搜索，找到所有以a为键的weak 对象，从而设置为 nil。 weak 修饰的指针默认值是nil ，在objective - c中向nil 发送消息是安全的。</p>

<p> 29、给类添加一个属性后，在类结构体 哪些元素会发生变化?  
 
 RunLoop 
 
 30、runloop是来做 么的?runloop和线程有 么关系?主线程默认开启 runloop么? 线程呢?  
 
 31、runloop的mode是用来做什么的?有几种mode?  
 
 32、为什么把NSTimer对象以NSDefaultRunLoopMode(kCFRunLoopDefaultMode)添加到主运 循环以后，滑动scrollview的时候NSTimer却不动 ?  
 
 33、苹果是如何实现AutoreleasePool的?  
 
 类结构 
 
 34、isa指针?(对象的isa，类对象的isa，元类的isa都要说)  
 
 35、类方法和实例法有什么区别?  
 
 36、介绍一下分类能用分类做什么?内部是如何实现的?与该类原有方法的名称相同 的时候，为什么原有的方法会失效?  
 
 37、运行时能增加成员变量么?能增加属性么?如果能，如何增加?如果不能，为什么?  
 
 38、objc中向一个nil对象发送消息将会发生什么?(返回值是对象，是标 ，结构体)  
 
 
 高级
 
 39、UITableview的优化方法(缓存度，异步绘制，减少层级，hide，避免离屏渲染)  
 
 40、有没有使用过运行时， 它都能做什么?(交换方法，创建类，给新创建的类增加方法，改变isa指针) 
  
 41、看过哪些第三方框架的源码?都是如何实现的?(如果没有，问下多图下载的设计思路)
  
 42、SDWebImage的缓存策 ? 
 
 SDWebImage 使用内存+硬盘的方式进行缓存。先把placeholderImage 显示，然后SDWebImageManager 根据URL 开始处理图片 。先查看缓存中是否已经下载该图片。先从内存中查找，如果内存中已经有图片缓存，那么调用出来直接显示，如果内存缓存中没有，生成NSInvocationOperation 添加到队列开始从硬盘查找图片是否缓存，根据URLKey 在硬盘缓存目录下尝试读取图片文件，这一步是在NSOperation 进行的操作，所以回主线程结果回调 notifyDelegate。如果从硬盘中读取到了图片，将图片添加到内存缓存中，如果空闲内存过小，会先清空内存缓存。回调展示图片。如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载该图片，回调 imageCache:didNotFindImageForKey:userInfo: 共享或者重新生成一个下载器SDWebImageDownliader开始下载图片。下载完成之后做图片解码处理。在子线程成中完成，不会拖慢主线程UI，展示图片。将图片保存到SDImageCAche中，内存缓存和硬盘缓存同时保存。写文件到硬盘也是在子线程完成。 
 43、AFN为什么添加一条常驻线程?  
 44、KVO的使 ?实现原理?(为什么要创建 类来实现)  
 45、KVC的使 ?实现原 ?(KVC拿到key以后，是如何赋值的?知 知道集合操作 符，能 能访问私有属性，能 能直接访问_ivar)  
 项目
 
 已上线项目？ 哪个部分是你完成的，遇到什么困难，怎么解决？</p>


  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/04/iOS-Runtime/" title="link to iOS - Runtime 的理解">iOS - Runtime 的理解</a></h2>
       <p class="excerpt">Runtime1、什么是Runtime？Runtime 又叫运行时，是一套底层的C语言API，是iOS内部的核心之一，OC代码的底层都是基于它来实现的，最终都是转化成了Runtime的C语言代码。其中最主要的就是消息机制OC中一切都被设计成对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象。为什么说oc是面向对象的动态语言？动态加载 例如2x 3x 图片动态类型，比如说id类型，在运行时才能确定到底是什么类型动态绑定，比如说，在编译时候并不能决定真...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-04-20 17:41:00 +0900" class="post-list__meta--date date">2018-04-20</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2018/04/iOS-Runtime/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/04/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="link to iOS - 内存管理">iOS - 内存管理</a></h2>
       <p class="excerpt">1、内存中五大区域栈区（stack）：储存局部变量、函数的参数值，当期作用域执行完毕之后，就会被系统立即收回，由编译器自动分配释放，其操作方式类似于数据结构中的栈，栈内存分配运算内置于指令集，效率很高，但是分配的内存容量有限，比如iOS中栈区的大小是2M。堆区（heap）：（就是通过new、malloc、realloc 分配的内存块，他们的释放编译器不去管，有我们的引用程序去释放，如果应用程序没有释放掉，操作系统会自动回收，分配方式类似于链表）存放OC对象，手动申请的空间，手动释放（ARC...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-04-20 10:41:00 +0900" class="post-list__meta--date date">2018-04-20</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2018/04/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://localhost:4000/2018/04/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/";
        this.page.identifier = "/2018/04/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/";
    };

    var disqus_shortname = 'vno-jekyll';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2018-04-20 生成，感谢 <a href="https://www.digitalocean.com/?refcode=30ed2d146762">Digital Ocean</a> 为本站提供稳定的 VPS 服务</span>
        <span class="footer__copyright">本站由 <a href="http://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
